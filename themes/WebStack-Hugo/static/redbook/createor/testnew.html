<div>
  testnew
  <script>
    async function fetchAndClean2222(url) {
      const proxyUrl = "https://cors-anywhere.herokuapp.com/";
      //   const proxyUrl = 'https://api.allorigins.win/get?url=';
      const res = await fetch(proxyUrl + url);
      const text = await res.text();

      const lines = text.trim().split("\n");
      // 去掉最后一行
      if (lines[lines.length - 1].includes("File Creation")) {
        lines.pop();
      }
      console.log(`总行数（含标题）: ${lines}`);

      const headers = lines[0].split("|").map((h) => h.trim());

      console.log(`总行数（含标题）222: ${headers}`);

      const data = lines.slice(1).map((line) => {
        const values = line.split("|");
        const obj = {};
        headers.forEach((h, i) => {
          obj[h] = (values[i] || "").trim();
        });
        return obj;
      });

      // 过滤
      const cleaned = data.filter(
        (row) =>
          row.Symbol &&
          !row.Symbol.includes("File Creation") &&
          row["Test Issue"] !== "Y"
        // && row['Financial Status'] !== 'D'   // 可选
      );

      console.log(`有效股票数量: ${cleaned.length}`);
      return cleaned.map((row) => ({
        symbol: row.Symbol,
        name: row["Security Name"],
        isETF: row.ETF === "Y",
      }));
    }

    // 用法
    // fetchAndClean(
    //   "https://www.nasdaqtrader.com/dynamic/symdir/nasdaqlisted.txt"
    // ).then(console.log);

    async function fetchAndClean(url, source = "unknown") {
      const proxyOptions = [
        { url: "https://cors-anywhere.herokuapp.com/", encode: false },
        { url: "https://api.allorigins.win/raw?url=", encode: true },
        { url: "https://cors-proxy.org/?", encode: false },
        { url: "https://thingproxy.freeboard.io/fetch/", encode: false },
      ];

      let text = null;
      let currentProxy = "";

      for (const proxy of proxyOptions) {
        try {
          currentProxy = proxy.url;
          const finalUrl = proxy.encode
            ? proxy.url + encodeURIComponent(url)
            : proxy.url + url.replace("http://", "").replace("https://", "");

          console.log(`尝试代理: ${currentProxy}`);
          const res = await fetch(finalUrl);

          if (!res.ok) {
            console.warn(`HTTP错误 ${res.status}: ${res.statusText}`);
            continue;
          }

          text = await res.text();
          if (text && text.length > 100) {
            break;
          }
        } catch (error) {
          console.warn(`代理 ${currentProxy} 失败:`, error.message);
          continue;
        }
      }

      if (!text) {
        throw new Error("无法从任何代理获取数据");
      }

      console.log("成功获取数据，长度:", text.length);

      let lines = text.trim().split(/\r?\n|\r/);

      // 查找表头位置 - 更灵活的方式
      let headerLineIndex = -1;
      for (let i = 0; i < Math.min(10, lines.length); i++) {
        const line = lines[i];
        if (
          line.includes("|") &&
          (line.toLowerCase().includes("symbol") ||
            line.toLowerCase().includes("security") ||
            line.toLowerCase().includes("company"))
        ) {
          headerLineIndex = i;
          break;
        }
      }

      if (headerLineIndex === -1) {
        console.error("未找到表头行，前几行内容:", lines.slice(0, 5));
        return [];
      }

      // 清理掉文件末尾的元信息
      lines = lines.filter(
        (line) =>
          !line.includes("File Creation Time") &&
          !line.includes("File Creation")
      );

      const headers = lines[headerLineIndex].split("|").map((h) => h.trim());
      const dataLines = lines.slice(headerLineIndex + 1);

      console.log(`表头: ${JSON.stringify(headers)}`);
      console.log(`数据行数: ${dataLines.length}`);
      console.log(`前3行数据:`, dataLines.slice(0, 3));

      // 转换数据
      const data = dataLines
        .filter((line) => line.trim() && line.includes("|"))
        .map((line) => {
          const values = line.split("|");
          const obj = {};
          headers.forEach((h, i) => {
            obj[h] = (values[i] || "").trim();
          });
          return obj;
        });

      console.log(`转换后前3个对象:`, data.slice(0, 3));

      // 更宽松的过滤条件
      const cleaned = data.filter((row) => {
        // 尝试多种可能的字段名
        const possibleSymbolKeys = [
          "Symbol",
          "ACT Symbol",
          "NASDAQ Symbol",
          "Symbol Name",
          "Ticker",
        ];
        const possibleTestIssueKeys = [
          "Test Issue",
          "TestIssue",
          "Test",
          "Issue Test",
        ];

        let symbolValue = null;
        let testIssueValue = null;

        for (const key of possibleSymbolKeys) {
          if (row.hasOwnProperty(key)) {
            symbolValue = row[key];
            break;
          }
        }

        for (const key of possibleTestIssueKeys) {
          if (row.hasOwnProperty(key)) {
            testIssueValue = row[key];
            break;
          }
        }

        // 如果找不到符号字段，则尝试第一个字段
        if (!symbolValue && headers.length > 0) {
          symbolValue = row[headers[0]];
        }

        const isValid =
          symbolValue &&
          symbolValue.trim() !== "" &&
          !symbolValue.includes("File Creation") &&
          testIssueValue !== "Y";

        if (!isValid) {
          console.log("被过滤的行:", row);
        }

        return isValid;
      });

      console.log(`有效记录数: ${cleaned.length}`);
      console.log(`前5个有效记录:`, cleaned.slice(0, 5));

      return cleaned.map((row) => {
        // 映射到标准字段
        const possibleSymbolKeys = [
          "Symbol",
          "ACT Symbol",
          "NASDAQ Symbol",
          "Symbol Name",
          "Ticker",
        ];
        const possibleNameKeys = [
          "Security Name",
          "Company Name",
          "Name",
          "Security Name:",
          "Description",
        ];
        const possibleETFKeys = ["ETF", "Type", "EquityType", "Fund Type"];

        let symbol = null;
        let name = "";
        let isETF = false;

        // 获取symbol - 按优先级查找，优先使用 Symbol 字段
        for (const key of possibleSymbolKeys) {
          if (row.hasOwnProperty(key) && row[key]) {
            symbol = row[key];
            break;
          }
        }

        // 如果还是null，使用第一个有效的字段
        if (!symbol) {
          for (const key in row) {
            if (row[key] && key.trim() !== "") {
              symbol = row[key];
              break;
            }
          }
        }

        // 获取name
        for (const key of possibleNameKeys) {
          if (row.hasOwnProperty(key)) {
            name = row[key] || "";
            break;
          }
        }

        // 获取ETF状态
        for (const key of possibleETFKeys) {
          if (row.hasOwnProperty(key)) {
            isETF = row[key] === "Y" || row[key] === "E" || row[key] === "ETF";
            break;
          }
        }

        return {
          symbol: symbol,
          name: name,
          isETF: isETF,
          source: source, // 添加来源标识
        };
      });
    }

    async function getAllUSStocks() {
      const [nasdaq, other] = await Promise.all([
        fetchAndClean(
          "https://www.nasdaqtrader.com/dynamic/symdir/nasdaqlisted.txt"
        ),
        fetchAndClean(
          "https://www.nasdaqtrader.com/dynamic/symdir/otherlisted.txt"
        ),
      ]);

      const all = [...nasdaq, ...other];
      console.log(nasdaq.length, other.length, all.length);

      // 去重：如果 nasdaqlisted 的 Symbol 与 otherlisted 的 ACT Symbol 相同，则移除 otherlisted 中的条目
      const nasdaqSymbols = new Set(nasdaq.map((item) => item.symbol));
      const seen = new Set();

      const unique = all.filter((row) => {
        if (!row.symbol) {
          return false;
        }

        // 如果这个符号已经在 NASDAQ 列表中出现过，则跳过（即使它来自 otherlisted）
        if (nasdaqSymbols.has(row.symbol)) {
          // 来自 NASDAQ 的保留
          if (!seen.has(row.symbol)) {
            seen.add(row.symbol);
            return true;
          }
          return false;
        } else {
          // 不在 NASDAQ 中的符号，正常处理避免重复
          if (!seen.has(row.symbol)) {
            seen.add(row.symbol);
            return true;
          }
          return false;
        }
      });

      console.log(`总共唯一股票/ETF: ${unique.length}`);
      console.log(`去重前: ${all.length}, 去重后: ${unique.length}`);
      return unique;
    }

    getAllUSStocks().then((data) => {
      console.log(data);
    });
  </script>
</div>
